# Рекомендації з розвитку CortexWatcher

## 1. Продуктові пріоритети
- **Розширити підключення джерел логів.** Поточна реалізація вже підтримує Telegram, HTTP API (GELF, Wazuh, JSON/NDJSON) та базові механізми нормалізації, що описано у README, тому наступним кроком може стати інтеграція з популярними брокерами подій (Kafka, NATS) та SIEM-платформами, щоб зменшити час онбордингу нових команд.【F:README.md†L5-L15】
- **Посилити можливості фронтенду.** FastAPI надає REST-ендпоінти для перегляду логів, алертів та аномалій, однак бракує готового UI. Варто передбачити легкий веб-клієнт або інтеграцію з Grafana/Streamlit для швидкої діагностики інцидентів.【F:README.md†L13-L21】【F:src/cortexwatcher/api/routers/query.py†L19-L70】
- **Вдосконалити роботу з Telegram.** Передбачити керування правами доступу з адмін-панелі, валідацію вкладень перед нормалізацією та можливість відповіді безпосередньо з бота на інцидент (acknowledgement). Це підсилить сценарій «моніторинг Telegram-груп», вже описаний у документації.【F:README.md†L49-L58】

## 2. Аналітика та виявлення загроз
- **Розширити підхід до аномалій.** Поточний `AnomalyDetector` оперує ковзним вікном та порогом z-score. Додайте підтримку адаптивних порогів, сезонності та навчання на основі історичних даних (наприклад, `EWMA`, `IsolationForest`). Для цього варто винести збереження історії до окремої таблиці, щоб мати контекст у довших часових проміжках.【F:src/cortexwatcher/analyzer/anomalies.py†L1-L44】
- **Консолідувати правила кореляції.** Механізм правил у YAML уже є, але доцільно забезпечити редактор правил і перевірку синтаксису перед деплоєм, а також сценарії комбінованих умов (часові вікна, кілька джерел). Це дозволить швидше впроваджувати нові детектори без змін у коді.【F:README.md†L7-L11】
- **Додати автоматизовану пріоритизацію алертів.** Збережені алерти наразі містять рівень та опис; наступний крок — обчислювати рівень ризику на основі контексту (частота, тип джерела, критичність сервісу) та відображати його у відповіді API й Telegram-нотифікаціях.【F:src/cortexwatcher/api/routers/query.py†L41-L67】

## 3. Дані та сховище
- **ClickHouse як основне сховище для масивів.** Інтерфейс `LogStorage` дозволяє підміняти реалізації. Запровадьте конфігураційне автодетектування та реплікацію у ClickHouse для важких сценаріїв, а PostgreSQL залиште як транзакційний шар для алертів і метаданих.【F:src/cortexwatcher/storage/base.py†L1-L53】【F:src/cortexwatcher/storage/postgres.py†L1-L95】
- **Оптимізувати пошук.** У PostgreSQL-запитах варто додати індекси по `ts`, `host`, `app` та `severity`, а також повнотекстовий пошук по `msg` (PG Trigram або TSVECTOR), бо зараз фільтри будуються простими `WHERE`/`ILIKE` і можуть ставати вузьким місцем при великих обʼємах.【F:src/cortexwatcher/storage/postgres.py†L18-L57】
- **Стандартизувати схему даних.** Формалізувати DTO для логів/алертів та версіонувати їх, аби зовнішні інтеграції могли оновлюватись без ризику зламати старі агенти.

## 4. API та безпека
- **Єдиний шар автентифікації.** API вже перевіряє токен для інжесту, але доцільно додати OAuth/OpenID інтеграцію для UI та забезпечити аудит усіх звернень, включно з пагінацією та rate-limit на рівні API gateway.【F:README.md†L17-L28】【F:tests/test_api.py†L27-L38】
- **Додати `/status` і self-check.** У README задачах вже згадано `/status`; реалізуйте ендпоінт, який перевірятиме з’єднання з БД, Redis, ClickHouse та стан черг, а також готуватиме метрики для Prometheus, щоб оперативно відслідковувати деградацію сервісів.【F:README.md†L62-L68】
- **Політика оновлень правил.** Реалізуйте цифровий підпис або контрольні суми для YAML-файлів правил, щоб унеможливити несанкціоновані зміни на проді.

## 5. Процеси розробки та якість
- **Покриття тестами критичних модулів.** Наразі тести охоплюють API, парсери та rules engine. Варто додати сценарії для сховищ, аномалій та Telegram-бота, щоб не допустити регресій у ключових pipeline-ах.【F:tests/test_api.py†L1-L42】【F:tests/test_parsers.py†L1-L37】【F:tests/test_rules_engine.py†L1-L25】
- **Стандартизувати pipelines CI/CD.** Включити lint (ruff/mypy), security scan (Bandit, Trivy), seed-дані для інтеграційних тестів і контроль покриття ≥80% для нових модулів.
- **Прозорий релізний цикл.** Запровадити release notes у `CHANGELOG.md` із фіксацією нових конекторів, правил, міграцій БД та інструкцій відкату, а також автоматизувати створення Docker-образів для staging/production.【F:CHANGELOG.md†L1-L64】

## 6. Спостережність та експлуатація
- **Prometheus-метрики та алерти.** Поточний стек уже надає `/metrics`; додайте власні метрики (швидкість інжесту, кількість алертів за рівнями, стан черг RQ) та побудуйте Grafana-дашборди для SOC/SRE команд.【F:README.md†L17-L21】
- **Playbooks для інцидентів.** Документуйте типові сценарії реагування (наприклад, при сплеску 5xx у NGINX) і додайте автоматичні дії через інтеграцію з PagerDuty/Slack.
- **Керування конфігурацією.** Перейдіть на declarative-конфігурацію (наприклад, GitOps із ArgoCD) для правил, pipelines та секретів, щоб гарантувати відстежуваність змін.

Ці кроки допоможуть структуровано розвивати CortexWatcher від MVP до повноцінної платформи моніторингу безпеки та операційної аналітики.
